// Gemini AI service for generating synthetic error logs
// Uses Google Gemini API directly via REST API

const DEFAULT_PROMPT = `You are a streaming data generator. Produce one realistic API error event in JSON format only.

Generate one JSON object with these fields:
timestamp, errorCode, error, errorCategory, errorLocation, apiName, errorReason,
awsCluster, actionToBeTaken, correlationId, orderId, serviceName, errorStackTrace.

Rules:
- Output strictly valid JSON (no code blocks or explanations)
- Use current UTC time for timestamp
- Use uppercase for API and service names
- Include realistic stack traces with at least 2 nested calls
- errorCategory must be one of: API_FAILURE, VALIDATION_ERROR, SYSTEM_ERROR, NETWORK_FAILURE
- All UUIDs must be valid v4 format
- The stack trace must look authentic with multiple nested calls (e.g., DAO → Manager → Service)`;

export async function generateSyntheticError(customPrompt = null) {
  const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
  
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY is not configured');
  }

  const prompt = customPrompt || DEFAULT_PROMPT;

  try {
    // Use REST API directly with available model
    // Available models: gemini-2.5-flash-preview-05-20, gemini-2.5-pro-preview-03-25
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt,
                },
              ],
            },
          ],
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', response.status, errorText);
      
      if (response.status === 429) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }
      
      if (response.status === 403 || response.status === 401) {
        throw new Error('API key invalid or quota exceeded. Please check your Gemini API key.');
      }
      
      throw new Error(`Gemini API error: ${response.status} - ${errorText.substring(0, 200)}`);
    }

    const data = await response.json();
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      console.error('No content in response:', JSON.stringify(data, null, 2));
      throw new Error('No content generated from Gemini');
    }

    // Clean up the response - remove markdown code blocks if present
    let cleanedText = generatedText.trim();
    if (cleanedText.startsWith('```json')) {
      cleanedText = cleanedText.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
    } else if (cleanedText.startsWith('```')) {
      cleanedText = cleanedText.replace(/```\n?/g, '');
    }

    // Parse the JSON
    try {
      const errorLog = JSON.parse(cleanedText);
      return errorLog;
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      console.error('Attempted to parse:', cleanedText);
      throw new Error('Invalid JSON generated by Gemini');
    }
  } catch (error) {
    console.error('Error in generateSyntheticError:', error);
    
    // Handle specific Gemini API errors
    if (error.message?.includes('429')) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }
    
    if (error.message?.includes('quota') || error.message?.includes('QUOTA')) {
      throw new Error('API quota exceeded. Please check your Gemini API quota.');
    }
    
    throw error;
  }
}

